# frozen_string_literal: true

require 'open3'
require 'json'
require_relative 'debug'

# Service class wrapping git operations for notebook version control.
# Provides methods for init, status, commit, push, pull, log, diff, show, and checkout.
class GitService
  include Debug

  # Initializes GitService with the notebook path as the git repository root.
  # @param notebook_path [String] Absolute path to the notebook directory
  def initialize(notebook_path)
    @repo_path = File.expand_path(notebook_path)
  end

  # Returns true if the notebook directory is a git repository.
  def repo?
    git_dir = File.join(@repo_path, '.git')
    File.directory?(git_dir) || File.exist?(git_dir)
  end

  # Initializes a git repository in the notebook directory.
  # Creates .gitignore to exclude .zh directory.
  # Optionally adds a remote.
  # @param remote [String, nil] Optional remote URL to add as 'origin'
  # @return [Hash] Result with :success and :message keys
  def init(remote: nil)
    return { success: false, message: 'Already a git repository' } if repo?

    # Initialize repository
    result = run_git('init')
    return result unless result[:success]

    # Create .gitignore
    gitignore_path = File.join(@repo_path, '.gitignore')
    gitignore_content = <<~GITIGNORE
      # ZettelHub index and local config (regenerated by zh reindex)
      .zh/
    GITIGNORE

    if File.exist?(gitignore_path)
      existing = File.read(gitignore_path)
      unless existing.include?('.zh/')
        File.write(gitignore_path, existing + "\n" + gitignore_content)
        debug_print('Updated .gitignore to exclude .zh/')
      end
    else
      File.write(gitignore_path, gitignore_content)
      debug_print('Created .gitignore')
    end

    # Add remote if provided
    if remote && !remote.empty?
      remote_result = run_git('remote', 'add', 'origin', remote)
      return remote_result unless remote_result[:success]
      debug_print("Added remote origin: #{remote}")
    end

    { success: true, message: 'Initialized git repository' }
  end

  # Returns git status as a hash with :modified, :added, :deleted, :untracked arrays.
  # Each array contains relative file paths.
  # @return [Hash] Status hash with file path arrays
  def status
    result = {
      modified: [],
      added: [],
      deleted: [],
      untracked: [],
      staged: []
    }

    return result unless repo?

    # Get porcelain status for parsing
    output = run_git_output('status', '--porcelain=v1')
    return result if output.nil?

    output.each_line do |line|
      next if line.strip.empty?

      index_status = line[0]
      worktree_status = line[1]
      filepath = line[3..].strip

      # Staged changes (index)
      case index_status
      when 'A'
        result[:staged] << filepath
        result[:added] << filepath
      when 'M'
        result[:staged] << filepath
        result[:modified] << filepath unless result[:modified].include?(filepath)
      when 'D'
        result[:staged] << filepath
        result[:deleted] << filepath
      end

      # Worktree changes (unstaged)
      case worktree_status
      when 'M'
        result[:modified] << filepath unless result[:modified].include?(filepath)
      when 'D'
        result[:deleted] << filepath unless result[:deleted].include?(filepath)
      when '?'
        result[:untracked] << filepath
      end
    end

    result[:staged].uniq!
    result
  end

  # Commits changes to the repository.
  # @param message [String] Commit message
  # @param paths [Array<String>, nil] Specific paths to commit (stages them first)
  # @param all [Boolean] If true, stages all changes before committing
  # @return [Hash] Result with :success and :message keys
  def commit(message:, paths: nil, all: false)
    return { success: false, message: 'Not a git repository' } unless repo?

    # Stage changes
    if paths && !paths.empty?
      paths.each do |path|
        relative_path = relative_to_repo(path)
        run_git('add', relative_path)
      end
    elsif all
      run_git('add', '-A')
    end

    # Check if there's anything to commit
    status_result = status
    if status_result[:staged].empty? && !all
      # Check for any staged changes
      check = run_git_output('diff', '--cached', '--name-only')
      if check.nil? || check.strip.empty?
        return { success: false, message: 'Nothing to commit' }
      end
    end

    run_git('commit', '-m', message)
  end

  # Pushes commits to remote repository.
  # @param remote [String] Remote name (default: origin)
  # @param branch [String] Branch name (default: main)
  # @return [Hash] Result with :success and :message keys
  def push(remote: 'origin', branch: 'main')
    return { success: false, message: 'Not a git repository' } unless repo?

    # Check if remote exists
    remotes = run_git_output('remote')
    unless remotes&.include?(remote)
      return { success: false, message: "Remote '#{remote}' not found" }
    end

    run_git('push', remote, branch)
  end

  # Pulls changes from remote repository.
  # @param remote [String] Remote name (default: origin)
  # @param branch [String] Branch name (default: main)
  # @return [Hash] Result with :success and :message keys
  def pull(remote: 'origin', branch: 'main')
    return { success: false, message: 'Not a git repository' } unless repo?

    # Check if remote exists
    remotes = run_git_output('remote')
    unless remotes&.include?(remote)
      return { success: false, message: "Remote '#{remote}' not found" }
    end

    run_git('pull', remote, branch)
  end

  # Returns git log for a file or the entire repository.
  # @param path [String, nil] File path to get history for (nil for all)
  # @param limit [Integer] Maximum number of commits to return
  # @return [Array<Hash>] Array of commit hashes with :hash, :date, :author, :message keys
  def log(path: nil, limit: 10)
    return [] unless repo?

    # Format: hash|date|author|subject
    format = '%H|%aI|%an|%s'
    args = ['log', "--format=#{format}", "-n", limit.to_s]

    if path
      relative_path = relative_to_repo(path)
      args << '--' << relative_path
    end

    output = run_git_output(*args)
    return [] if output.nil? || output.strip.empty?

    output.each_line.map do |line|
      parts = line.strip.split('|', 4)
      next if parts.length < 4

      {
        hash: parts[0],
        date: parts[1],
        author: parts[2],
        message: parts[3]
      }
    end.compact
  end

  # Returns diff output for a file or the entire repository.
  # @param path [String, nil] File path to diff (nil for all)
  # @param commit [String, nil] Commit hash to compare against (nil for working tree)
  # @param staged [Boolean] If true, show staged changes
  # @return [String] Diff output
  def diff(path: nil, commit: nil, staged: false)
    return '' unless repo?

    args = ['diff']
    args << '--cached' if staged
    args << commit if commit
    
    if path
      relative_path = relative_to_repo(path)
      args << '--' << relative_path
    end

    run_git_output(*args) || ''
  end

  # Returns file content at a specific commit.
  # @param commit [String] Commit hash
  # @param path [String] File path
  # @return [String, nil] File content or nil if not found
  def show(commit:, path:)
    return nil unless repo?

    relative_path = relative_to_repo(path)
    run_git_output('show', "#{commit}:#{relative_path}")
  end

  # Restores a file to a specific commit version.
  # @param path [String] File path to restore
  # @param commit [String] Commit hash to restore from
  # @return [Hash] Result with :success and :message keys
  def checkout(path:, commit:)
    return { success: false, message: 'Not a git repository' } unless repo?

    relative_path = relative_to_repo(path)
    run_git('checkout', commit, '--', relative_path)
  end

  # Returns the current branch name.
  # @return [String, nil] Branch name or nil if not in a repo
  def current_branch
    return nil unless repo?

    output = run_git_output('rev-parse', '--abbrev-ref', 'HEAD')
    output&.strip
  end

  # Returns true if there are uncommitted changes.
  # @return [Boolean]
  def dirty?
    return false unless repo?

    s = status
    s[:modified].any? || s[:added].any? || s[:deleted].any? || s[:untracked].any?
  end

  # Returns true if there are commits to push.
  # @param remote [String] Remote name
  # @param branch [String] Branch name
  # @return [Boolean]
  def ahead?(remote: 'origin', branch: 'main')
    return false unless repo?

    output = run_git_output('rev-list', '--count', "#{remote}/#{branch}..HEAD")
    output&.strip.to_i.positive?
  rescue StandardError
    false
  end

  # Returns true if there are commits to pull.
  # @param remote [String] Remote name
  # @param branch [String] Branch name
  # @return [Boolean]
  def behind?(remote: 'origin', branch: 'main')
    return false unless repo?

    # Fetch to update remote refs
    run_git('fetch', remote, branch)
    output = run_git_output('rev-list', '--count', "HEAD..#{remote}/#{branch}")
    output&.strip.to_i.positive?
  rescue StandardError
    false
  end

  private

  # Converts an absolute path to a path relative to the repository.
  # @param path [String] Absolute or relative path
  # @return [String] Path relative to repository root
  def relative_to_repo(path)
    abs_path = File.expand_path(path, @repo_path)
    if abs_path.start_with?(@repo_path)
      abs_path[@repo_path.length + 1..] || '.'
    else
      path
    end
  end

  # Runs a git command and returns result hash.
  # @return [Hash] Result with :success, :message, :output keys
  def run_git(*args)
    debug_print("git #{args.join(' ')}")
    
    stdout, stderr, status = Open3.capture3('git', *args, chdir: @repo_path)
    
    if status.success?
      debug_print("git success: #{stdout.strip}")
      { success: true, message: stdout.strip, output: stdout }
    else
      debug_print("git error: #{stderr.strip}")
      { success: false, message: stderr.strip, output: stderr }
    end
  rescue StandardError => e
    debug_print("git exception: #{e.message}")
    { success: false, message: e.message, output: '' }
  end

  # Runs a git command and returns stdout only.
  # @return [String, nil] stdout or nil on error
  def run_git_output(*args)
    debug_print("git #{args.join(' ')}")
    
    stdout, stderr, status = Open3.capture3('git', *args, chdir: @repo_path)
    
    if status.success?
      stdout
    else
      debug_print("git error: #{stderr.strip}")
      nil
    end
  rescue StandardError => e
    debug_print("git exception: #{e.message}")
    nil
  end
end
